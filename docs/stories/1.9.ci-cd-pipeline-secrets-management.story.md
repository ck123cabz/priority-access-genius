# Story 1.9: CI/CD Pipeline & Secrets Management

## Status

Done

## Story

**As a** developer,
**I want** a CI/CD pipeline that automatically tests and deploys the application,
**so that** changes can be delivered confidently.

## Acceptance Criteria

1. A GitHub Actions workflow is created to run tests (unit, E2E) on every push
2. The workflow deploys to Vercel on merge to `main`
3. Environment variables are securely managed using Vercel and Supabase project settings

## Tasks / Subtasks

- [x] Create comprehensive GitHub Actions test workflow (AC: 1)
  - [x] Create `.github/workflows/test.yml` with unit test job
  - [x] Add E2E test job with Playwright
  - [x] Configure test jobs to run on push and pull request events
  - [x] Set up Node.js 20 and pnpm installation steps
  - [x] Configure test database for integration tests
  - [x] Add linting and type checking to test pipeline

- [x] Create Supabase deployment workflow (AC: 2)
  - [x] Create `.github/workflows/supabase-deploy.yml` for database deployments
  - [x] Configure Supabase CLI setup and authentication
  - [x] Add database migration deployment steps
  - [x] Add edge function deployment for generate-pdf and webhook-dispatcher
  - [x] Configure secrets management for Supabase service role key

- [x] Configure Vercel deployment integration (AC: 2)
  - [x] Import GitHub repository into Vercel
  - [x] Configure automatic deployment on merge to main
  - [x] Set up preview deployments for pull requests
  - [x] Configure build settings for Next.js application

- [x] Implement secure environment variable management (AC: 3)
  - [x] Configure Vercel environment variables for all environments
  - [x] Set up Supabase project environment variables
  - [x] Document environment variable requirements and setup process
  - [x] Implement environment-specific configuration validation
  - [x] Add environment variable validation in application startup

- [x] Set up deployment environments and promotion strategy (AC: 2)
  - [x] Configure preview environment for pull requests
  - [x] Set up staging environment for main branch deployments
  - [x] Configure production deployment with tagged releases
  - [x] Document promotion strategy from preview to staging to production
  - [x] Add deployment status checks and notifications

- [x] Create deployment monitoring and rollback procedures (AC: 2, 3)
  - [x] Add deployment success/failure notifications
  - [x] Document rollback procedures for failed deployments
  - [x] Set up basic deployment health checks
  - [x] Configure deployment logging and error tracking
  - [x] Create incident response procedures for deployment failures

## Dev Notes

### Previous Story Insights

Story 1.8 successfully implemented global error handling with comprehensive testing infrastructure. The application now has a robust foundation with authentication, dashboard functionality, client management, real-time updates, and error handling. The CI/CD story builds upon this solid technical foundation to provide automated testing and deployment capabilities, ensuring code quality and reliable delivery.

### Data Models

No specific database schema changes required for this story. CI/CD pipeline works with existing data models and will validate database migrations as part of the deployment process.

### API Specifications

[Source: architecture/14-deployment-architecture.md]
**Deployment Environments:**
- Preview: every PR — Vercel Preview, isolated Supabase schema (optional)
- Staging: `main` branch — Vercel env = `staging`, Supabase project `staging`
- Production: tagged release — Vercel env = `production`, Supabase `prod`

**Supabase Deploy Configuration:**
- Database migrations via `supabase db push`
- Edge function deployment: generate-pdf, webhook-dispatcher
- Secrets management for SUPABASE_SERVICE_ROLE_KEY
- Project linking via SUPABASE_PROJECT_REF

### Component Specifications

[Source: architecture/16-testing-strategy.md]
**CI Integration Workflow:**
```yaml
name: CI
on: [push, pull_request]
jobs:
  unit:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: { node-version: '20' }
      - run: pnpm install --frozen-lockfile
      - run: pnpm test -- --ci
  e2e:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: { node-version: '20' }
      - run: pnpm install --frozen-lockfile
      - run: pnpm build --filter web
      - run: npx playwright install --with-deps
      - run: pnpm exec playwright test
```

[Source: architecture/14-deployment-architecture.md]
**Supabase Deploy Workflow:**
```yaml
name: Supabase Deploy
on:
  push:
    branches: [ main ]
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: supabase/setup-cli@v1
      - run: supabase link --project-ref ${{ secrets.SUPABASE_PROJECT_REF }}
      - run: supabase db push
      - run: supabase functions deploy generate-pdf --no-verify-jwt
      - run: supabase functions deploy webhook-dispatcher --no-verify-jwt
      - run: supabase secrets set SUPABASE_SERVICE_ROLE_KEY=${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
```

### File Locations

[Source: architecture/12-unified-project-structure.md]
Based on the unified project structure, new files needed:
```
.github/workflows/
  test.yml                               # Comprehensive test workflow (unit + E2E)
  supabase-deploy.yml                    # Supabase deployment workflow
  deployment-health-check.yml            # Optional deployment health checks
```

**Existing Files to Modify:**
- `package.json` - Add CI/CD related scripts if needed
- `apps/web/package.json` - Ensure test scripts are properly configured
- `packages/db/package.json` - Ensure migration and seed scripts exist
- `README.md` - Add deployment and CI/CD documentation

**Environment Configuration Files:**
- Vercel project settings (environment variables)
- Supabase project settings (secrets and environment configuration)
- `.env.example` - Document required environment variables

### Testing Requirements

[Source: architecture/16-testing-strategy.md]
- **Testing Framework:** Jest ~29.7 + React Testing Library for unit tests
- **E2E Testing:** Playwright ~1.44 with browser matrix (Chrome, Safari, Mobile)
- **Test Configuration:** Jest config at `apps/web/jest.config.ts`, Playwright config at `playwright.config.ts`
- **CI Test Strategy:**
  - Unit tests run on every push and pull request
  - E2E tests run on every push and pull request
  - Tests must pass before merge to main
  - Test coverage validation for new code

**Critical Test Scenarios for CI/CD:**
- Smoke flow: activation link -> sign -> confirm -> download PDF
- Error handling: invalid tokens, network failures, PDF generation timeouts
- Security: unauthorized access attempts, XSS prevention
- Mobile responsiveness: full flow on mobile devices
- Performance: page load times under 2 seconds

**Mock Data Strategy:**
- Test client records pre-seeded in test database
- Mock PDF service returns predictable test PDFs
- Simulated network conditions for testing
- Authentication mocks for different permission levels

### Technical Constraints

[Source: architecture/3-tech-stack.md]
- **Frontend Framework:** Next.js ~14.2 with App Router
- **Testing:** Jest ~29.7 + React Testing Library, Playwright ~1.44
- **Deployment:** Vercel for hosting, Supabase for backend services
- **CI/CD Platform:** GitHub Actions
- **Node.js Version:** 20 (as specified in testing strategy)
- **Package Manager:** pnpm with workspaces

[Source: architecture/14-deployment-architecture.md]
**Deployment Constraints:**
- Vercel deployment must use Next.js defaults for build output
- Supabase edge functions deployed with --no-verify-jwt flag
- Environment variables managed per environment (preview, staging, production)
- Promotion strategy: PR -> Preview -> merge to main -> auto deploy to Staging -> tag for Production

### Security Requirements

[Source: architecture/15-security-performance.md]
- Environment variables must be securely managed in Vercel and Supabase
- No secrets should be exposed in CI/CD logs or build output
- Database access limited by RLS policies during CI/CD operations
- Deployment authentication must use secure tokens and service keys
- CI/CD workflows should validate security configurations

**Secrets Management:**
- `SUPABASE_PROJECT_REF` for project linking
- `SUPABASE_SERVICE_ROLE_KEY` for administrative operations
- Vercel environment variables for application configuration
- GitHub secrets for workflow authentication

### Performance Considerations

**CI/CD Performance:**
- Parallel execution of unit and E2E tests where possible
- Efficient caching of node_modules and build artifacts
- Fast deployment pipelines with minimal downtime
- Health checks to validate deployment success
- Rollback procedures for failed deployments

**Build Optimization:**
- Next.js build optimization for production deployments
- Efficient Docker layer caching if containerization is added
- Parallel test execution to reduce CI/CD runtime
- Incremental builds where supported by platform

### Coding Standards

[Source: architecture/17-coding-standards.md]
- CI/CD workflows follow YAML best practices and GitHub Actions standards
- Service layer pattern maintained for deployment-related operations
- ESLint + Prettier enforced in CI pipeline
- Configuration files follow established project conventions
- Documentation standards for deployment procedures

### Project Structure Notes

The existing monorepo structure with pnpm workspaces provides an excellent foundation for CI/CD implementation. The separation of `apps/web` and `packages/db` allows for targeted testing and deployment strategies. The existing `.github/workflows/db-migration.yml` demonstrates the project's readiness for GitHub Actions workflows. The Supabase configuration and Vercel integration align perfectly with the planned CI/CD approach.

**Existing CI/CD Foundation:**
- Database migration validation workflow already exists
- pnpm workspace configuration supports multi-package testing
- Supabase configuration files ready for deployment automation
- Next.js application structure compatible with Vercel deployment

## Testing

### Testing Standards

[Source: architecture/16-testing-strategy.md]
- **Testing Framework:** Jest ~29.7 + React Testing Library for unit tests
- **E2E Testing:** Playwright ~1.44 for end-to-end testing
- **Test File Location:** `apps/web/src/**/__tests__/` or co-located with components
- **Setup:** Jest config at `apps/web/jest.config.ts`, Playwright config at `playwright.config.ts`
- **CI Integration:** Tests run in GitHub Actions workflow on every push and pull request

**CI/CD Testing Strategy:**
- Unit tests must pass before deployment
- E2E tests validate critical user flows in CI environment
- Integration tests verify deployment configuration
- Security tests validate environment variable handling
- Performance tests ensure deployment doesn't degrade application performance

**Test Types Required:**
- Unit tests for any new configuration utilities
- Integration tests for CI/CD workflow validation
- E2E tests for complete application flows in deployed environments
- Security tests for secrets management validation
- Deployment health checks and smoke tests

**Mock Strategy for CI/CD:**
- Mock external services during CI test runs
- Test database setup and teardown for integration tests
- Simulated deployment environments for testing
- Mock authentication services for automated testing

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-20 | 1.0 | Initial story creation | BMad Agent (Scrum Master) |

## Dev Agent Record

### Agent Model Used

claude-sonnet-4-20250514

### Debug Log References

No critical debugging was required. All workflows and configurations were implemented following architecture specifications.

### Completion Notes

Successfully implemented comprehensive CI/CD pipeline with the following key components:

1. **Test Workflow**: Complete GitHub Actions pipeline with unit tests, E2E tests, linting, type checking, integration tests, and security checks
2. **Supabase Deployment**: Automated database migrations and edge function deployments with environment-specific configurations
3. **Vercel Integration**: Automatic deployments with preview environments for PRs and production deployments for releases
4. **Environment Management**: Comprehensive environment variable validation and secure secrets management across all environments
5. **Deployment Strategy**: Four-tier deployment strategy (Development → Preview → Staging → Production) with proper promotion workflows
6. **Monitoring & Rollback**: Health check endpoints, automated notifications, comprehensive rollback procedures, and incident response workflows

All acceptance criteria met:
- AC 1: GitHub Actions workflow runs tests on every push ✅
- AC 2: Workflow deploys to Vercel on merge to main ✅  
- AC 3: Environment variables securely managed using Vercel and Supabase project settings ✅

### File List

**New Files Created:**
- `.github/workflows/test.yml` - Comprehensive test pipeline
- `.github/workflows/supabase-deploy.yml` - Supabase deployment workflow
- `.github/workflows/vercel-deploy.yml` - Vercel deployment workflow
- `.github/workflows/deployment-pipeline.yml` - Unified deployment pipeline
- `.github/workflows/deployment-notifications.yml` - Deployment monitoring and notifications
- `vercel.json` - Vercel deployment configuration
- `apps/web/src/lib/env-validation.ts` - Environment variable validation utility
- `apps/web/src/app/api/health/route.ts` - Application health check endpoint
- `docs/deployment/vercel-setup.md` - Vercel configuration documentation
- `docs/deployment/environment-variables.md` - Environment variable management guide
- `docs/deployment/promotion-strategy.md` - Deployment environments and promotion strategy
- `docs/deployment/rollback-procedures.md` - Comprehensive rollback and incident response procedures

**Modified Files:**
- `.env.example` - Updated with comprehensive environment variable documentation and examples

## QA Results

### Review Date: 2025-08-20

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

Excellent implementation of a comprehensive CI/CD pipeline with robust security measures and modern DevOps practices. The multi-tier deployment strategy (Preview → Staging → Production) follows industry best practices. All GitHub Actions workflows are well-structured with proper error handling, secrets management, and comprehensive testing. The environment validation utilities provide excellent runtime safety. All acceptance criteria have been thoroughly implemented with additional security enhancements.

### Refactoring Performed

- **File**: apps/web/src/app/api/health/route.ts
  - **Change**: Fixed uptime calculation to use process.uptime() instead of startTime calculation
  - **Why**: Provides accurate application uptime rather than health check duration
  - **How**: Replaced manual calculation with Node.js built-in process.uptime() method

- **File**: apps/web/src/lib/env-validation.ts
  - **Change**: Updated Supabase JWT key length validation from 100 to 150 characters
  - **Why**: Supabase JWTs are typically 150+ characters, previous validation was too lenient
  - **How**: Increased minimum length requirement for more accurate validation

- **File**: .github/workflows/test.yml
  - **Change**: Enhanced security check to detect JWT tokens and hardcoded URLs in code
  - **Why**: Prevents accidental exposure of sensitive credentials in version control
  - **How**: Added comprehensive regex patterns to detect JWT tokens and Supabase URLs

- **File**: .github/workflows/supabase-deploy.yml
  - **Change**: Added database diff check before deploying migrations
  - **Why**: Prevents unnecessary deployments when no database changes exist
  - **How**: Uses supabase db diff command to detect pending migrations

- **File**: .github/workflows/deployment-pipeline.yml
  - **Change**: Improved health check with retry logic and proper status validation
  - **Why**: Ensures deployments are truly healthy before marking as successful
  - **How**: Added retry mechanism with JSON status parsing for reliable health checks

- **File**: apps/web/tests/setup.ts
  - **Change**: Added comprehensive Jest setup with Next.js mocks and environment configuration
  - **Why**: Enables proper unit testing for all components and utilities
  - **How**: Configured Router mocks, environment variables, and browser APIs for testing

### Compliance Check

- Coding Standards: ✓ All workflows follow YAML best practices, proper naming conventions
- Project Structure: ✓ Files organized according to GitHub Actions conventions in .github/workflows/
- Testing Strategy: ✓ Comprehensive test pipeline with unit, E2E, integration, and security tests
- All ACs Met: ✓ GitHub Actions workflow, Vercel deployment, and secure environment management fully implemented

### Improvements Checklist

- [x] Fixed health check endpoint uptime calculation (apps/web/src/app/api/health/route.ts)
- [x] Enhanced environment variable validation with proper JWT key lengths (apps/web/src/lib/env-validation.ts)
- [x] Improved security scanning in CI pipeline with JWT and URL detection (.github/workflows/test.yml)
- [x] Added database diff check to prevent unnecessary deployments (.github/workflows/supabase-deploy.yml)
- [x] Implemented robust health check retry logic with JSON parsing (.github/workflows/deployment-pipeline.yml)
- [x] Created comprehensive Jest test setup with Next.js mocks (apps/web/tests/setup.ts)
- [ ] Consider adding smoke tests for critical user flows in E2E pipeline
- [ ] Consider implementing deployment rollback automation for failed health checks
- [ ] Add Slack/Discord notifications for deployment status updates
- [ ] Consider implementing blue-green deployments for zero-downtime releases

### Security Review

✓ **Secrets Management**: All sensitive data properly managed through GitHub Secrets and Vercel environment variables
✓ **Environment Isolation**: Separate configurations for preview, staging, and production environments
✓ **Access Control**: Proper use of GitHub environment protection rules and approval workflows
✓ **Code Scanning**: Comprehensive security checks prevent hardcoded secrets and JWT tokens in code
✓ **JWT Validation**: Environment validation ensures proper format and length of Supabase JWTs
✓ **Database Security**: RLS policies maintained, database migrations use secure service role keys
✓ **Network Security**: Health checks validate HTTPS endpoints and proper SSL/TLS configuration

### Performance Considerations

✓ **Parallel Execution**: Tests run in parallel jobs for optimal CI/CD performance
✓ **Caching Strategy**: pnpm store caching reduces dependency installation time
✓ **Health Checks**: Comprehensive health monitoring with retry logic ensures deployment reliability
✓ **Build Optimization**: Next.js build optimization configured for production deployments
✓ **Resource Management**: PostgreSQL service containers properly configured with health checks

### Files Modified During Review

- apps/web/src/app/api/health/route.ts (uptime calculation fix)
- apps/web/src/lib/env-validation.ts (JWT validation enhancement)
- .github/workflows/test.yml (enhanced security scanning)
- .github/workflows/supabase-deploy.yml (database diff check)
- .github/workflows/deployment-pipeline.yml (improved health checks)
- apps/web/tests/setup.ts (comprehensive test setup)

### Gate Status

Gate: PASS → docs/qa/gates/1.9-ci-cd-pipeline-secrets-management.yml

### Recommended Status

✓ Ready for Done - All acceptance criteria exceeded with robust security implementation, comprehensive testing infrastructure, and production-ready CI/CD pipeline. Excellent DevOps practices and security controls implemented.